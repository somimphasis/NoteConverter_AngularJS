angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.modal", "ui.bootstrap.multiMap", "ui.bootstrap.stackedMap", "ui.bootstrap.position"]), angular.module("ui.bootstrap.tpls", ["uib/template/modal/window.html"]), angular.module("ui.bootstrap.modal", ["ui.bootstrap.multiMap", "ui.bootstrap.stackedMap", "ui.bootstrap.position"]).provider("$uibResolve", function () { var e = this; this.resolver = null, this.setResolver = function (e) { this.resolver = e }, this.$get = ["$injector", "$q", function (t, o) { var n = e.resolver ? t.get(e.resolver) : null; return { resolve: function (e, r, a, i) { if (n) return n.resolve(e, r, a, i); var l = []; return angular.forEach(e, function (e) { angular.isFunction(e) || angular.isArray(e) ? l.push(o.resolve(t.invoke(e))) : angular.isString(e) ? l.push(o.resolve(t.get(e))) : l.push(o.resolve(e)) }), o.all(l).then(function (t) { var o = {}, n = 0; return angular.forEach(e, function (e, r) { o[r] = t[n++] }), o }) } } }] }).directive("uibModalBackdrop", ["$animate", "$injector", "$uibModalStack", function (e, t, o) { return { restrict: "A", compile: function (e, t) { return e.addClass(t.backdropClass), n } }; function n(t, n, r) { r.modalInClass && (e.addClass(n, r.modalInClass), t.$on(o.NOW_CLOSING_EVENT, function (o, a) { var i = a(); t.modalOptions.animation ? e.removeClass(n, r.modalInClass).then(i) : i() })) } }]).directive("uibModalWindow", ["$uibModalStack", "$q", "$animateCss", "$document", function (e, t, o, n) { return { scope: { index: "@" }, restrict: "A", transclude: !0, templateUrl: function (e, t) { return t.templateUrl || "uib/template/modal/window.html" }, link: function (r, a, i) { a.addClass(i.windowTopClass || ""), r.size = i.size, r.close = function (t) { var o = e.getTop(); o && o.value.backdrop && "static" !== o.value.backdrop && t.target === t.currentTarget && (t.preventDefault(), t.stopPropagation(), e.dismiss(o.key, "backdrop click")) }, a.on("click", r.close), r.$isRendered = !0; var l = t.defer(); r.$$postDigest(function () { l.resolve() }), l.promise.then(function () { var l = null; i.modalInClass && (l = o(a, { addClass: i.modalInClass }).start(), r.$on(e.NOW_CLOSING_EVENT, function (e, t) { var n = t(); o(a, { removeClass: i.modalInClass }).start().then(n) })), t.when(l).then(function () { var t = e.getTop(); if (t && e.modalRendered(t.key), !n[0].activeElement || !a[0].contains(n[0].activeElement)) { var o = a[0].querySelector("[autofocus]"); o ? o.focus() : a[0].focus() } }) }) } } }]).directive("uibModalAnimationClass", function () { return { compile: function (e, t) { t.modalAnimation && e.addClass(t.uibModalAnimationClass) } } }).directive("uibModalTransclude", ["$animate", function (e) { return { link: function (t, o, n, r, a) { a(t.$parent, function (t) { o.empty(), e.enter(t, o) }) } } }]).factory("$uibModalStack", ["$animate", "$animateCss", "$document", "$compile", "$rootScope", "$q", "$$multiMap", "$$stackedMap", "$uibPosition", function (e, t, o, n, r, a, i, l, s) { var d, u, c, p = "modal-open", f = l.createNew(), m = i.createNew(), h = { NOW_CLOSING_EVENT: "modal.stack.now-closing" }, g = 0, b = null, v = "data-bootstrap-modal-aria-hidden-count", w = /[A-Z]/g; function $() { for (var e = -1, t = f.keys(), o = 0; o < t.length; o++) f.get(t[o]).value.backdrop && (e = o); return e } function y(e, t) { var o = f.get(e).value, n = o.appendTo; f.remove(e), (b = f.top()) && (g = parseInt(b.value.modalDomEl.attr("index"), 10)), C(o.modalDomEl, o.modalScope, function () { var t = o.openedClass || p; m.remove(t, e); var r = m.hasKey(t); n.toggleClass(t, r), !r && c && c.heightOverflow && c.scrollbarWidth && (c.originalRight ? n.css({ paddingRight: c.originalRight + "px" }) : n.css({ paddingRight: "" }), c = null), k(!0) }, o.closedDeferred), function () { if (d && -1 === $()) { C(d, u, function () { null }), d = void 0, u = void 0 } }(), t && t.focus ? t.focus() : n.focus && n.focus() } function k(e) { var t; f.length() > 0 && (t = f.top().value).modalDomEl.toggleClass(t.windowTopClass || "", e) } function C(t, o, n, r) { var i, l = null; return o.$broadcast(h.NOW_CLOSING_EVENT, function () { return i || (i = a.defer(), l = i.promise), function () { i.resolve() } }), a.when(l).then(function a() { if (a.done) return; a.done = !0; e.leave(t).then(function () { n && n(), t.remove(), r && r.resolve() }); o.$destroy() }) } function S(e) { if (e.isDefaultPrevented()) return e; var t = f.top(); if (t) switch (e.which) { case 27: t.value.keyboard && (e.preventDefault(), r.$apply(function () { h.dismiss(t.key, "escape key press") })); break; case 9: var o = h.loadFocusElementList(t), n = !1; e.shiftKey ? (h.isFocusInFirstItem(e, o) || h.isModalFocused(e, t)) && (n = h.focusLastFocusableElement(o)) : h.isFocusInLastItem(e, o) && (n = h.focusFirstFocusableElement(o)), n && (e.preventDefault(), e.stopPropagation()) } } function E(e, t, o) { return !e.value.modalScope.$broadcast("modal.closing", t, o).defaultPrevented } function M() { Array.prototype.forEach.call(document.querySelectorAll("[" + v + "]"), function (e) { var t = parseInt(e.getAttribute(v), 10) - 1; e.setAttribute(v, t), t || (e.removeAttribute(v), e.removeAttribute("aria-hidden")) }) } return r.$watch($, function (e) { u && (u.index = e) }), o.on("keydown", S), r.$on("$destroy", function () { o.off("keydown", S) }), h.open = function (t, a) { var i = o[0].activeElement, l = a.openedClass || p; k(!1), b = f.top(), f.add(t, { deferred: a.deferred, renderDeferred: a.renderDeferred, closedDeferred: a.closedDeferred, modalScope: a.scope, backdrop: a.backdrop, keyboard: a.keyboard, openedClass: a.openedClass, windowTopClass: a.windowTopClass, animation: a.animation, appendTo: a.appendTo }), m.put(l, t); var h, y = a.appendTo, C = $(); C >= 0 && !d && ((u = r.$new(!0)).modalOptions = a, u.index = C, (d = angular.element('<div uib-modal-backdrop="modal-backdrop"></div>')).attr({ class: "modal-backdrop", "ng-style": "{'z-index': 1040 + (index && 1 || 0) + index*10}", "uib-modal-animation-class": "fade", "modal-in-class": "in" }), a.backdropClass && d.addClass(a.backdropClass), a.animation && d.attr("modal-animation", "true"), n(d)(u), e.enter(d, y), s.isScrollable(y) && (c = s.scrollbarPadding(y)).heightOverflow && c.scrollbarWidth && y.css({ paddingRight: c.right + "px" })), a.component ? (h = document.createElement(a.component.name.replace(w, function (e, t) { return (t ? "-" : "") + e.toLowerCase() })), (h = angular.element(h)).attr({ resolve: "$resolve", "modal-instance": "$uibModalInstance", close: "$close($value)", dismiss: "$dismiss($value)" })) : h = a.content, g = b ? parseInt(b.value.modalDomEl.attr("index"), 10) + 1 : 0; var S = angular.element('<div uib-modal-window="modal-window"></div>'); S.attr({ class: "modal", "template-url": a.windowTemplateUrl, "window-top-class": a.windowTopClass, role: "dialog", "aria-labelledby": a.ariaLabelledBy, "aria-describedby": a.ariaDescribedBy, size: a.size, index: g, animate: "animate", "ng-style": "{'z-index': 1050 + $$topModalIndex*10, display: 'block'}", tabindex: -1, "uib-modal-animation-class": "fade", "modal-in-class": "in" }).append(h), a.windowClass && S.addClass(a.windowClass), a.animation && S.attr("modal-animation", "true"), y.addClass(l), a.scope && (a.scope.$$topModalIndex = g), e.enter(n(S)(a.scope), y), f.top().value.modalDomEl = S, f.top().value.modalOpener = i, function e(t) { if (!t || "BODY" === t[0].tagName) return; (o = t, n = o.parent() ? o.parent().children() : [], Array.prototype.filter.call(n, function (e) { return e !== o[0] })).forEach(function (e) { var t = "true" === e.getAttribute("aria-hidden"), o = parseInt(e.getAttribute(v), 10); o || (o = t ? 1 : 0), e.setAttribute(v, o + 1), e.setAttribute("aria-hidden", "true") }); var o, n; return e(t.parent()) }(S) }, h.close = function (e, t) { var o = f.get(e); return M(), o && E(o, t, !0) ? (o.value.modalScope.$$uibDestructionScheduled = !0, o.value.deferred.resolve(t), y(e, o.value.modalOpener), !0) : !o }, h.dismiss = function (e, t) { var o = f.get(e); return M(), o && E(o, t, !1) ? (o.value.modalScope.$$uibDestructionScheduled = !0, o.value.deferred.reject(t), y(e, o.value.modalOpener), !0) : !o }, h.dismissAll = function (e) { for (var t = this.getTop() ; t && this.dismiss(t.key, e) ;) t = this.getTop() }, h.getTop = function () { return f.top() }, h.modalRendered = function (e) { var t = f.get(e); t && t.value.renderDeferred.resolve() }, h.focusFirstFocusableElement = function (e) { return e.length > 0 && (e[0].focus(), !0) }, h.focusLastFocusableElement = function (e) { return e.length > 0 && (e[e.length - 1].focus(), !0) }, h.isModalFocused = function (e, t) { if (e && t) { var o = t.value.modalDomEl; if (o && o.length) return (e.target || e.srcElement) === o[0] } return !1 }, h.isFocusInFirstItem = function (e, t) { return t.length > 0 && (e.target || e.srcElement) === t[0] }, h.isFocusInLastItem = function (e, t) { return t.length > 0 && (e.target || e.srcElement) === t[t.length - 1] }, h.loadFocusElementList = function (e) { if (e) { var t = e.value.modalDomEl; if (t && t.length) { var o = t[0].querySelectorAll("a[href], area[href], input:not([disabled]):not([tabindex='-1']), button:not([disabled]):not([tabindex='-1']),select:not([disabled]):not([tabindex='-1']), textarea:not([disabled]):not([tabindex='-1']), iframe, object, embed, *[tabindex]:not([tabindex='-1']), *[contenteditable=true]"); return o ? Array.prototype.filter.call(o, function (e) { return !!((t = e).offsetWidth || t.offsetHeight || t.getClientRects().length); var t }) : o } } }, h }]).provider("$uibModal", function () { var e = { options: { animation: !0, backdrop: !0, keyboard: !0 }, $get: ["$rootScope", "$q", "$document", "$templateRequest", "$controller", "$uibResolve", "$uibModalStack", function (t, o, n, r, a, i, l) { var s = {}; var d = null; return s.getPromiseChain = function () { return d }, s.open = function (s) { var u, c, p, f = o.defer(), m = o.defer(), h = o.defer(), g = o.defer(), b = { result: f.promise, opened: m.promise, closed: h.promise, rendered: g.promise, close: function (e) { return l.close(b, e) }, dismiss: function (e) { return l.dismiss(b, e) } }; if ((s = angular.extend({}, e.options, s)).resolve = s.resolve || {}, s.appendTo = s.appendTo || n.find("body").eq(0), !s.appendTo.length) throw new Error("appendTo element not found. Make sure that the element passed is in DOM."); if (!s.component && !s.template && !s.templateUrl) throw new Error("One of component or template or templateUrl options is required."); function v() { return u } return u = s.component ? o.when(i.resolve(s.resolve, {}, null, null)) : o.all([(c = s, c.template ? o.when(c.template) : r(angular.isFunction(c.templateUrl) ? c.templateUrl() : c.templateUrl)), i.resolve(s.resolve, {}, null, null)]), p = d = o.all([d]).then(v, v).then(function (e) { var o = s.scope || t, n = o.$new(); n.$close = b.close, n.$dismiss = b.dismiss, n.$on("$destroy", function () { n.$$uibDestructionScheduled || n.$dismiss("$uibUnscheduledDestruction") }); var r, i, d = { scope: n, deferred: f, renderDeferred: g, closedDeferred: h, animation: s.animation, backdrop: s.backdrop, keyboard: s.keyboard, backdropClass: s.backdropClass, windowTopClass: s.windowTopClass, windowClass: s.windowClass, windowTemplateUrl: s.windowTemplateUrl, ariaLabelledBy: s.ariaLabelledBy, ariaDescribedBy: s.ariaDescribedBy, size: s.size, openedClass: s.openedClass, appendTo: s.appendTo }, u = {}, c = {}; function p(t, o, r, a) { t.$scope = n, t.$scope.$resolve = {}, r ? t.$scope.$uibModalInstance = b : t.$uibModalInstance = b; var i = o ? e[1] : e; angular.forEach(i, function (e, o) { a && (t[o] = e), t.$scope.$resolve[o] = e }) } s.component ? (p(u, !1, !0, !1), u.name = s.component, d.component = u) : s.controller && (p(c, !0, !1, !0), i = a(s.controller, c, !0, s.controllerAs), s.controllerAs && s.bindToController && ((r = i.instance).$close = n.$close, r.$dismiss = n.$dismiss, angular.extend(r, { $resolve: c.$scope.$resolve }, o)), r = i(), angular.isFunction(r.$onInit) && r.$onInit()), s.component || (d.content = e[0]), l.open(b, d), m.resolve(!0) }, function (e) { m.reject(e), f.reject(e) }).finally(function () { d === p && (d = null) }), b }, s }] }; return e }), angular.module("ui.bootstrap.multiMap", []).factory("$$multiMap", function () { return { createNew: function () { var e = {}; return { entries: function () { return Object.keys(e).map(function (t) { return { key: t, value: e[t] } }) }, get: function (t) { return e[t] }, hasKey: function (t) { return !!e[t] }, keys: function () { return Object.keys(e) }, put: function (t, o) { e[t] || (e[t] = []), e[t].push(o) }, remove: function (t, o) { var n = e[t]; if (n) { var r = n.indexOf(o); -1 !== r && n.splice(r, 1), n.length || delete e[t] } } } } } }), angular.module("ui.bootstrap.stackedMap", []).factory("$$stackedMap", function () { return { createNew: function () { var e = []; return { add: function (t, o) { e.push({ key: t, value: o }) }, get: function (t) { for (var o = 0; o < e.length; o++) if (t === e[o].key) return e[o] }, keys: function () { for (var t = [], o = 0; o < e.length; o++) t.push(e[o].key); return t }, top: function () { return e[e.length - 1] }, remove: function (t) { for (var o = -1, n = 0; n < e.length; n++) if (t === e[n].key) { o = n; break } return e.splice(o, 1)[0] }, removeTop: function () { return e.pop() }, length: function () { return e.length } } } } }), angular.module("ui.bootstrap.position", []).factory("$uibPosition", ["$document", "$window", function (e, t) { var o, n, r = { normal: /(auto|scroll)/, hidden: /(auto|scroll|hidden)/ }, a = { auto: /\s?auto?\s?/i, primary: /^(top|bottom|left|right)$/, secondary: /^(top|bottom|left|right|center)$/, vertical: /^(top|bottom)$/ }, i = /(HTML|BODY)/; return { getRawNode: function (e) { return e.nodeName ? e : e[0] || e }, parseStyle: function (e) { return e = parseFloat(e), isFinite(e) ? e : 0 }, offsetParent: function (o) { var n, r = (o = this.getRawNode(o)).offsetParent || e[0].documentElement; for (; r && r !== e[0].documentElement && (n = r, "static" === (t.getComputedStyle(n).position || "static")) ;) r = r.offsetParent; return r || e[0].documentElement }, scrollbarWidth: function (r) { if (r) { if (angular.isUndefined(n)) { var a = e.find("body"); a.addClass("uib-position-body-scrollbar-measure"), n = t.innerWidth - a[0].clientWidth, n = isFinite(n) ? n : 0, a.removeClass("uib-position-body-scrollbar-measure") } return n } if (angular.isUndefined(o)) { var i = angular.element('<div class="uib-position-scrollbar-measure"></div>'); e.find("body").append(i), o = i[0].offsetWidth - i[0].clientWidth, o = isFinite(o) ? o : 0, i.remove() } return o }, scrollbarPadding: function (e) { e = this.getRawNode(e); var o = t.getComputedStyle(e), n = this.parseStyle(o.paddingRight), r = this.parseStyle(o.paddingBottom), a = this.scrollParent(e, !1, !0), l = this.scrollbarWidth(i.test(a.tagName)); return { scrollbarWidth: l, widthOverflow: a.scrollWidth > a.clientWidth, right: n + l, originalRight: n, heightOverflow: a.scrollHeight > a.clientHeight, bottom: r + l, originalBottom: r } }, isScrollable: function (e, o) { e = this.getRawNode(e); var n = o ? r.hidden : r.normal, a = t.getComputedStyle(e); return n.test(a.overflow + a.overflowY + a.overflowX) }, scrollParent: function (o, n, a) { o = this.getRawNode(o); var i = n ? r.hidden : r.normal, l = e[0].documentElement, s = t.getComputedStyle(o); if (a && i.test(s.overflow + s.overflowY + s.overflowX)) return o; var d = "absolute" === s.position, u = o.parentElement || l; if (u === l || "fixed" === s.position) return l; for (; u.parentElement && u !== l;) { var c = t.getComputedStyle(u); if (d && "static" !== c.position && (d = !1), !d && i.test(c.overflow + c.overflowY + c.overflowX)) break; u = u.parentElement } return u }, position: function (o, n) { o = this.getRawNode(o); var r = this.offset(o); if (n) { var a = t.getComputedStyle(o); r.top -= this.parseStyle(a.marginTop), r.left -= this.parseStyle(a.marginLeft) } var i = this.offsetParent(o), l = { top: 0, left: 0 }; return i !== e[0].documentElement && ((l = this.offset(i)).top += i.clientTop - i.scrollTop, l.left += i.clientLeft - i.scrollLeft), { width: Math.round(angular.isNumber(r.width) ? r.width : o.offsetWidth), height: Math.round(angular.isNumber(r.height) ? r.height : o.offsetHeight), top: Math.round(r.top - l.top), left: Math.round(r.left - l.left) } }, offset: function (o) { var n = (o = this.getRawNode(o)).getBoundingClientRect(); return { width: Math.round(angular.isNumber(n.width) ? n.width : o.offsetWidth), height: Math.round(angular.isNumber(n.height) ? n.height : o.offsetHeight), top: Math.round(n.top + (t.pageYOffset || e[0].documentElement.scrollTop)), left: Math.round(n.left + (t.pageXOffset || e[0].documentElement.scrollLeft)) } }, viewportOffset: function (o, n, r) { r = !1 !== r; var a = (o = this.getRawNode(o)).getBoundingClientRect(), i = { top: 0, left: 0, bottom: 0, right: 0 }, l = n ? e[0].documentElement : this.scrollParent(o), s = l.getBoundingClientRect(); if (i.top = s.top + l.clientTop, i.left = s.left + l.clientLeft, l === e[0].documentElement && (i.top += t.pageYOffset, i.left += t.pageXOffset), i.bottom = i.top + l.clientHeight, i.right = i.left + l.clientWidth, r) { var d = t.getComputedStyle(l); i.top += this.parseStyle(d.paddingTop), i.bottom -= this.parseStyle(d.paddingBottom), i.left += this.parseStyle(d.paddingLeft), i.right -= this.parseStyle(d.paddingRight) } return { top: Math.round(a.top - i.top), bottom: Math.round(i.bottom - a.bottom), left: Math.round(a.left - i.left), right: Math.round(i.right - a.right) } }, parsePlacement: function (e) { var t = a.auto.test(e); return t && (e = e.replace(a.auto, "")), (e = e.split("-"))[0] = e[0] || "top", a.primary.test(e[0]) || (e[0] = "top"), e[1] = e[1] || "center", a.secondary.test(e[1]) || (e[1] = "center"), e[2] = !!t, e }, positionElements: function (e, o, n, r) { e = this.getRawNode(e), o = this.getRawNode(o); var i = angular.isDefined(o.offsetWidth) ? o.offsetWidth : o.prop("offsetWidth"), l = angular.isDefined(o.offsetHeight) ? o.offsetHeight : o.prop("offsetHeight"); n = this.parsePlacement(n); var s = r ? this.offset(e) : this.position(e), d = { top: 0, left: 0, placement: "" }; if (n[2]) { var u = this.viewportOffset(e, r), c = t.getComputedStyle(o), p = i + Math.round(Math.abs(this.parseStyle(c.marginLeft) + this.parseStyle(c.marginRight))), f = l + Math.round(Math.abs(this.parseStyle(c.marginTop) + this.parseStyle(c.marginBottom))); if (n[0] = "top" === n[0] && f > u.top && f <= u.bottom ? "bottom" : "bottom" === n[0] && f > u.bottom && f <= u.top ? "top" : "left" === n[0] && p > u.left && p <= u.right ? "right" : "right" === n[0] && p > u.right && p <= u.left ? "left" : n[0], n[1] = "top" === n[1] && f - s.height > u.bottom && f - s.height <= u.top ? "bottom" : "bottom" === n[1] && f - s.height > u.top && f - s.height <= u.bottom ? "top" : "left" === n[1] && p - s.width > u.right && p - s.width <= u.left ? "right" : "right" === n[1] && p - s.width > u.left && p - s.width <= u.right ? "left" : n[1], "center" === n[1]) if (a.vertical.test(n[0])) { var m = s.width / 2 - i / 2; u.left + m < 0 && p - s.width <= u.right ? n[1] = "left" : u.right + m < 0 && p - s.width <= u.left && (n[1] = "right") } else { var h = s.height / 2 - f / 2; u.top + h < 0 && f - s.height <= u.bottom ? n[1] = "top" : u.bottom + h < 0 && f - s.height <= u.top && (n[1] = "bottom") } } switch (n[0]) { case "top": d.top = s.top - l; break; case "bottom": d.top = s.top + s.height; break; case "left": d.left = s.left - i; break; case "right": d.left = s.left + s.width } switch (n[1]) { case "top": d.top = s.top; break; case "bottom": d.top = s.top + s.height - l; break; case "left": d.left = s.left; break; case "right": d.left = s.left + s.width - i; break; case "center": a.vertical.test(n[0]) ? d.left = s.left + s.width / 2 - i / 2 : d.top = s.top + s.height / 2 - l / 2 } return d.top = Math.round(d.top), d.left = Math.round(d.left), d.placement = "center" === n[1] ? n[0] : n[0] + "-" + n[1], d }, adjustTop: function (e, t, o, n) { if (-1 !== e.indexOf("top") && o !== n) return { top: t.top - n + "px" } }, positionArrow: function (e, o) { var n = (e = this.getRawNode(e)).querySelector(".tooltip-inner, .popover-inner"); if (n) { var r = angular.element(n).hasClass("tooltip-inner"), i = r ? e.querySelector(".tooltip-arrow") : e.querySelector(".arrow"); if (i) { var l = { top: "", bottom: "", left: "", right: "" }; if ("center" !== (o = this.parsePlacement(o))[1]) { var s = "border-" + o[0] + "-width", d = t.getComputedStyle(i)[s], u = "border-"; a.vertical.test(o[0]) ? u += o[0] + "-" + o[1] : u += o[1] + "-" + o[0], u += "-radius"; var c = t.getComputedStyle(r ? n : e)[u]; switch (o[0]) { case "top": l.bottom = r ? "0" : "-" + d; break; case "bottom": l.top = r ? "0" : "-" + d; break; case "left": l.right = r ? "0" : "-" + d; break; case "right": l.left = r ? "0" : "-" + d } l[o[1]] = c, angular.element(i).css(l) } else angular.element(i).css(l) } } } } }]), angular.module("uib/template/modal/window.html", []).run(["$templateCache", function (e) { e.put("uib/template/modal/window.html", "<div class=\"modal-dialog {{size ? 'modal-' + size : ''}}\"><div class=\"modal-content\" uib-modal-transclude></div></div>\n") }]), angular.module("ui.bootstrap.position").run(function () { !angular.$$csp().noInlineStyle && !angular.$$uibPositionCss && angular.element(document).find("head").prepend('<style type="text/css">.uib-position-measure{display:block !important;visibility:hidden !important;position:absolute !important;top:-9999px !important;left:-9999px !important;}.uib-position-scrollbar-measure{position:absolute !important;top:-9999px !important;width:50px !important;height:50px !important;overflow:scroll !important;}.uib-position-body-scrollbar-measure{overflow:scroll !important;}</style>'), angular.$$uibPositionCss = !0 });